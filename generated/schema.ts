// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  TypedMap,
  Entity,
  Value,
  ValueKind,
  store,
  Bytes,
  BigInt,
  BigDecimal
} from "@graphprotocol/graph-ts";

export class AnyoneCallableUpdated extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("_status", Value.fromBoolean(false));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save AnyoneCallableUpdated entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save AnyoneCallableUpdated entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("AnyoneCallableUpdated", id.toString(), this);
    }
  }

  static load(id: string): AnyoneCallableUpdated | null {
    return changetype<AnyoneCallableUpdated | null>(
      store.get("AnyoneCallableUpdated", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get _status(): boolean {
    let value = this.get("_status");
    return value!.toBoolean();
  }

  set _status(value: boolean) {
    this.set("_status", Value.fromBoolean(value));
  }
}

export class CallerStatusUpdated extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("_caller", Value.fromBytes(Bytes.empty()));
    this.set("_status", Value.fromBoolean(false));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save CallerStatusUpdated entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save CallerStatusUpdated entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("CallerStatusUpdated", id.toString(), this);
    }
  }

  static load(id: string): CallerStatusUpdated | null {
    return changetype<CallerStatusUpdated | null>(
      store.get("CallerStatusUpdated", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get _caller(): Bytes {
    let value = this.get("_caller");
    return value!.toBytes();
  }

  set _caller(value: Bytes) {
    this.set("_caller", Value.fromBytes(value));
  }

  get _status(): boolean {
    let value = this.get("_status");
    return value!.toBoolean();
  }

  set _status(value: boolean) {
    this.set("_status", Value.fromBoolean(value));
  }
}

export class Transaction extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("timestamp", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Transaction entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save Transaction entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("Transaction", id.toString(), this);
    }
  }

  static load(id: string): Transaction | null {
    return changetype<Transaction | null>(store.get("Transaction", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get from(): Bytes | null {
    let value = this.get("from");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set from(value: Bytes | null) {
    if (!value) {
      this.unset("from");
    } else {
      this.set("from", Value.fromBytes(<Bytes>value));
    }
  }

  get to(): Bytes | null {
    let value = this.get("to");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set to(value: Bytes | null) {
    if (!value) {
      this.unset("to");
    } else {
      this.set("to", Value.fromBytes(<Bytes>value));
    }
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value!.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get gasLimit(): BigInt | null {
    let value = this.get("gasLimit");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set gasLimit(value: BigInt | null) {
    if (!value) {
      this.unset("gasLimit");
    } else {
      this.set("gasLimit", Value.fromBigInt(<BigInt>value));
    }
  }

  get gasPriceInGwei(): BigInt | null {
    let value = this.get("gasPriceInGwei");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set gasPriceInGwei(value: BigInt | null) {
    if (!value) {
      this.unset("gasPriceInGwei");
    } else {
      this.set("gasPriceInGwei", Value.fromBigInt(<BigInt>value));
    }
  }
}

export class Transfer extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("txnHash", Value.fromBytes(Bytes.empty()));
    this.set("value", Value.fromBigInt(BigInt.zero()));
    this.set("setToken", Value.fromString(""));
    this.set("timestamp", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Transfer entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save Transfer entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("Transfer", id.toString(), this);
    }
  }

  static load(id: string): Transfer | null {
    return changetype<Transfer | null>(store.get("Transfer", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get txnHash(): Bytes {
    let value = this.get("txnHash");
    return value!.toBytes();
  }

  set txnHash(value: Bytes) {
    this.set("txnHash", Value.fromBytes(value));
  }

  get from(): Bytes | null {
    let value = this.get("from");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set from(value: Bytes | null) {
    if (!value) {
      this.unset("from");
    } else {
      this.set("from", Value.fromBytes(<Bytes>value));
    }
  }

  get to(): Bytes | null {
    let value = this.get("to");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set to(value: Bytes | null) {
    if (!value) {
      this.unset("to");
    } else {
      this.set("to", Value.fromBytes(<Bytes>value));
    }
  }

  get value(): BigInt {
    let value = this.get("value");
    return value!.toBigInt();
  }

  set value(value: BigInt) {
    this.set("value", Value.fromBigInt(value));
  }

  get setToken(): string {
    let value = this.get("setToken");
    return value!.toString();
  }

  set setToken(value: string) {
    this.set("setToken", Value.fromString(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value!.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }
}

export class FeeRecipientUpdated extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("_setToken", Value.fromBytes(Bytes.empty()));
    this.set("_newFeeRecipient", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save FeeRecipientUpdated entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save FeeRecipientUpdated entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("FeeRecipientUpdated", id.toString(), this);
    }
  }

  static load(id: string): FeeRecipientUpdated | null {
    return changetype<FeeRecipientUpdated | null>(
      store.get("FeeRecipientUpdated", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get _setToken(): Bytes {
    let value = this.get("_setToken");
    return value!.toBytes();
  }

  set _setToken(value: Bytes) {
    this.set("_setToken", Value.fromBytes(value));
  }

  get _newFeeRecipient(): Bytes {
    let value = this.get("_newFeeRecipient");
    return value!.toBytes();
  }

  set _newFeeRecipient(value: Bytes) {
    this.set("_newFeeRecipient", Value.fromBytes(value));
  }
}

export class IssueFeeUpdated extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("_setToken", Value.fromBytes(Bytes.empty()));
    this.set("_newIssueFee", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save IssueFeeUpdated entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save IssueFeeUpdated entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("IssueFeeUpdated", id.toString(), this);
    }
  }

  static load(id: string): IssueFeeUpdated | null {
    return changetype<IssueFeeUpdated | null>(store.get("IssueFeeUpdated", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get _setToken(): Bytes {
    let value = this.get("_setToken");
    return value!.toBytes();
  }

  set _setToken(value: Bytes) {
    this.set("_setToken", Value.fromBytes(value));
  }

  get _newIssueFee(): BigInt {
    let value = this.get("_newIssueFee");
    return value!.toBigInt();
  }

  set _newIssueFee(value: BigInt) {
    this.set("_newIssueFee", Value.fromBigInt(value));
  }
}

export class RedeemFeeUpdated extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("_setToken", Value.fromBytes(Bytes.empty()));
    this.set("_newRedeemFee", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save RedeemFeeUpdated entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save RedeemFeeUpdated entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("RedeemFeeUpdated", id.toString(), this);
    }
  }

  static load(id: string): RedeemFeeUpdated | null {
    return changetype<RedeemFeeUpdated | null>(
      store.get("RedeemFeeUpdated", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get _setToken(): Bytes {
    let value = this.get("_setToken");
    return value!.toBytes();
  }

  set _setToken(value: Bytes) {
    this.set("_setToken", Value.fromBytes(value));
  }

  get _newRedeemFee(): BigInt {
    let value = this.get("_newRedeemFee");
    return value!.toBigInt();
  }

  set _newRedeemFee(value: BigInt) {
    this.set("_newRedeemFee", Value.fromBigInt(value));
  }
}

export class Issuer extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("address", Value.fromBytes(Bytes.empty()));
    this.set("setTokensIssued", Value.fromStringArray(new Array(0)));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Issuer entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save Issuer entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("Issuer", id.toString(), this);
    }
  }

  static load(id: string): Issuer | null {
    return changetype<Issuer | null>(store.get("Issuer", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get address(): Bytes {
    let value = this.get("address");
    return value!.toBytes();
  }

  set address(value: Bytes) {
    this.set("address", Value.fromBytes(value));
  }

  get setTokensIssued(): Array<string> {
    let value = this.get("setTokensIssued");
    return value!.toStringArray();
  }

  set setTokensIssued(value: Array<string>) {
    this.set("setTokensIssued", Value.fromStringArray(value));
  }
}

export class TokenIssuance extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("buyerAddress", Value.fromBytes(Bytes.empty()));
    this.set("setToken", Value.fromString(""));
    this.set("quantity", Value.fromBigInt(BigInt.zero()));
    this.set("issuer", Value.fromString(""));
    this.set("transaction", Value.fromString(""));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save TokenIssuance entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save TokenIssuance entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("TokenIssuance", id.toString(), this);
    }
  }

  static load(id: string): TokenIssuance | null {
    return changetype<TokenIssuance | null>(store.get("TokenIssuance", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get buyerAddress(): Bytes {
    let value = this.get("buyerAddress");
    return value!.toBytes();
  }

  set buyerAddress(value: Bytes) {
    this.set("buyerAddress", Value.fromBytes(value));
  }

  get setToken(): string {
    let value = this.get("setToken");
    return value!.toString();
  }

  set setToken(value: string) {
    this.set("setToken", Value.fromString(value));
  }

  get quantity(): BigInt {
    let value = this.get("quantity");
    return value!.toBigInt();
  }

  set quantity(value: BigInt) {
    this.set("quantity", Value.fromBigInt(value));
  }

  get issuer(): string {
    let value = this.get("issuer");
    return value!.toString();
  }

  set issuer(value: string) {
    this.set("issuer", Value.fromString(value));
  }

  get transaction(): string {
    let value = this.get("transaction");
    return value!.toString();
  }

  set transaction(value: string) {
    this.set("transaction", Value.fromString(value));
  }
}

export class SetToken extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("address", Value.fromBytes(Bytes.empty()));
    this.set("name", Value.fromString(""));
    this.set("manager", Value.fromString(""));
    this.set("issuer", Value.fromString(""));
    this.set("totalSupply", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save SetToken entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save SetToken entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("SetToken", id.toString(), this);
    }
  }

  static load(id: string): SetToken | null {
    return changetype<SetToken | null>(store.get("SetToken", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get address(): Bytes {
    let value = this.get("address");
    return value!.toBytes();
  }

  set address(value: Bytes) {
    this.set("address", Value.fromBytes(value));
  }

  get name(): string {
    let value = this.get("name");
    return value!.toString();
  }

  set name(value: string) {
    this.set("name", Value.fromString(value));
  }

  get manager(): string {
    let value = this.get("manager");
    return value!.toString();
  }

  set manager(value: string) {
    this.set("manager", Value.fromString(value));
  }

  get issuer(): string {
    let value = this.get("issuer");
    return value!.toString();
  }

  set issuer(value: string) {
    this.set("issuer", Value.fromString(value));
  }

  get issuances(): Array<string> {
    let value = this.get("issuances");
    return value!.toStringArray();
  }

  set issuances(value: Array<string>) {
    this.set("issuances", Value.fromStringArray(value));
  }

  get totalSupply(): BigInt {
    let value = this.get("totalSupply");
    return value!.toBigInt();
  }

  set totalSupply(value: BigInt) {
    this.set("totalSupply", Value.fromBigInt(value));
  }

  get rebalances(): Array<string> {
    let value = this.get("rebalances");
    return value!.toStringArray();
  }

  set rebalances(value: Array<string>) {
    this.set("rebalances", Value.fromStringArray(value));
  }

  get redemptions(): Array<string> {
    let value = this.get("redemptions");
    return value!.toStringArray();
  }

  set redemptions(value: Array<string>) {
    this.set("redemptions", Value.fromStringArray(value));
  }
}

export class Fee extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("timestamp", Value.fromBigInt(BigInt.zero()));
    this.set("manager", Value.fromString(""));
    this.set("transaction", Value.fromString(""));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Fee entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save Fee entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("Fee", id.toString(), this);
    }
  }

  static load(id: string): Fee | null {
    return changetype<Fee | null>(store.get("Fee", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value!.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get manager(): string {
    let value = this.get("manager");
    return value!.toString();
  }

  set manager(value: string) {
    this.set("manager", Value.fromString(value));
  }

  get managerPayout(): BigInt | null {
    let value = this.get("managerPayout");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set managerPayout(value: BigInt | null) {
    if (!value) {
      this.unset("managerPayout");
    } else {
      this.set("managerPayout", Value.fromBigInt(<BigInt>value));
    }
  }

  get protocolPayout(): BigInt | null {
    let value = this.get("protocolPayout");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set protocolPayout(value: BigInt | null) {
    if (!value) {
      this.unset("protocolPayout");
    } else {
      this.set("protocolPayout", Value.fromBigInt(<BigInt>value));
    }
  }

  get transaction(): string {
    let value = this.get("transaction");
    return value!.toString();
  }

  set transaction(value: string) {
    this.set("transaction", Value.fromString(value));
  }
}

export class RebalanceDetails extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("currentLeverageRatio", Value.fromBigInt(BigInt.zero()));
    this.set("newLeverageRatio", Value.fromBigInt(BigInt.zero()));
    this.set("chunkRebalanceNotional", Value.fromBigInt(BigInt.zero()));
    this.set("totalRebalanceNotional", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save RebalanceDetails entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save RebalanceDetails entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("RebalanceDetails", id.toString(), this);
    }
  }

  static load(id: string): RebalanceDetails | null {
    return changetype<RebalanceDetails | null>(
      store.get("RebalanceDetails", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get currentLeverageRatio(): BigInt {
    let value = this.get("currentLeverageRatio");
    return value!.toBigInt();
  }

  set currentLeverageRatio(value: BigInt) {
    this.set("currentLeverageRatio", Value.fromBigInt(value));
  }

  get newLeverageRatio(): BigInt {
    let value = this.get("newLeverageRatio");
    return value!.toBigInt();
  }

  set newLeverageRatio(value: BigInt) {
    this.set("newLeverageRatio", Value.fromBigInt(value));
  }

  get chunkRebalanceNotional(): BigInt {
    let value = this.get("chunkRebalanceNotional");
    return value!.toBigInt();
  }

  set chunkRebalanceNotional(value: BigInt) {
    this.set("chunkRebalanceNotional", Value.fromBigInt(value));
  }

  get totalRebalanceNotional(): BigInt {
    let value = this.get("totalRebalanceNotional");
    return value!.toBigInt();
  }

  set totalRebalanceNotional(value: BigInt) {
    this.set("totalRebalanceNotional", Value.fromBigInt(value));
  }
}

export class Rebalance extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("rebalanceDetails", Value.fromString(""));
    this.set("transaction", Value.fromString(""));
    this.set("transactionHash", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Rebalance entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save Rebalance entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("Rebalance", id.toString(), this);
    }
  }

  static load(id: string): Rebalance | null {
    return changetype<Rebalance | null>(store.get("Rebalance", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get setToken(): string {
    let value = this.get("setToken");
    return value!.toString();
  }

  set setToken(value: string) {
    this.set("setToken", Value.fromString(value));
  }

  get rebalanceDetails(): string {
    let value = this.get("rebalanceDetails");
    return value!.toString();
  }

  set rebalanceDetails(value: string) {
    this.set("rebalanceDetails", Value.fromString(value));
  }

  get transaction(): string {
    let value = this.get("transaction");
    return value!.toString();
  }

  set transaction(value: string) {
    this.set("transaction", Value.fromString(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class Manager extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("address", Value.fromBytes(Bytes.empty()));
    this.set("setToken", Value.fromString(""));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Manager entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save Manager entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("Manager", id.toString(), this);
    }
  }

  static load(id: string): Manager | null {
    return changetype<Manager | null>(store.get("Manager", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get address(): Bytes {
    let value = this.get("address");
    return value!.toBytes();
  }

  set address(value: Bytes) {
    this.set("address", Value.fromBytes(value));
  }

  get feeAccrualHistory(): Array<string> {
    let value = this.get("feeAccrualHistory");
    return value!.toStringArray();
  }

  set feeAccrualHistory(value: Array<string>) {
    this.set("feeAccrualHistory", Value.fromStringArray(value));
  }

  get totalFees(): BigInt | null {
    let value = this.get("totalFees");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set totalFees(value: BigInt | null) {
    if (!value) {
      this.unset("totalFees");
    } else {
      this.set("totalFees", Value.fromBigInt(<BigInt>value));
    }
  }

  get setToken(): string {
    let value = this.get("setToken");
    return value!.toString();
  }

  set setToken(value: string) {
    this.set("setToken", Value.fromString(value));
  }
}

export class TokenRedemption extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("setToken", Value.fromString(""));
    this.set("redeemer", Value.fromBytes(Bytes.empty()));
    this.set("transaction", Value.fromString(""));
    this.set("quantity", Value.fromBigInt(BigInt.zero()));
    this.set("fee", Value.fromString(""));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save TokenRedemption entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save TokenRedemption entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("TokenRedemption", id.toString(), this);
    }
  }

  static load(id: string): TokenRedemption | null {
    return changetype<TokenRedemption | null>(store.get("TokenRedemption", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get setToken(): string {
    let value = this.get("setToken");
    return value!.toString();
  }

  set setToken(value: string) {
    this.set("setToken", Value.fromString(value));
  }

  get redeemer(): Bytes {
    let value = this.get("redeemer");
    return value!.toBytes();
  }

  set redeemer(value: Bytes) {
    this.set("redeemer", Value.fromBytes(value));
  }

  get transaction(): string {
    let value = this.get("transaction");
    return value!.toString();
  }

  set transaction(value: string) {
    this.set("transaction", Value.fromString(value));
  }

  get quantity(): BigInt {
    let value = this.get("quantity");
    return value!.toBigInt();
  }

  set quantity(value: BigInt) {
    this.set("quantity", Value.fromBigInt(value));
  }

  get fee(): string {
    let value = this.get("fee");
    return value!.toString();
  }

  set fee(value: string) {
    this.set("fee", Value.fromString(value));
  }
}

export class SetTokenRedeemed extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("_setToken", Value.fromBytes(Bytes.empty()));
    this.set("_redeemer", Value.fromBytes(Bytes.empty()));
    this.set("_to", Value.fromBytes(Bytes.empty()));
    this.set("transaction", Value.fromString(""));
    this.set("_managerFee", Value.fromBigInt(BigInt.zero()));
    this.set("_protocolFee", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save SetTokenRedeemed entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save SetTokenRedeemed entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("SetTokenRedeemed", id.toString(), this);
    }
  }

  static load(id: string): SetTokenRedeemed | null {
    return changetype<SetTokenRedeemed | null>(
      store.get("SetTokenRedeemed", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get _setToken(): Bytes {
    let value = this.get("_setToken");
    return value!.toBytes();
  }

  set _setToken(value: Bytes) {
    this.set("_setToken", Value.fromBytes(value));
  }

  get _redeemer(): Bytes {
    let value = this.get("_redeemer");
    return value!.toBytes();
  }

  set _redeemer(value: Bytes) {
    this.set("_redeemer", Value.fromBytes(value));
  }

  get _to(): Bytes {
    let value = this.get("_to");
    return value!.toBytes();
  }

  set _to(value: Bytes) {
    this.set("_to", Value.fromBytes(value));
  }

  get transaction(): string {
    let value = this.get("transaction");
    return value!.toString();
  }

  set transaction(value: string) {
    this.set("transaction", Value.fromString(value));
  }

  get _managerFee(): BigInt {
    let value = this.get("_managerFee");
    return value!.toBigInt();
  }

  set _managerFee(value: BigInt) {
    this.set("_managerFee", Value.fromBigInt(value));
  }

  get _protocolFee(): BigInt {
    let value = this.get("_protocolFee");
    return value!.toBigInt();
  }

  set _protocolFee(value: BigInt) {
    this.set("_protocolFee", Value.fromBigInt(value));
  }
}

export class Disengaged extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("timestamp", Value.fromBigInt(BigInt.zero()));
    this.set("currentLeverageRatio", Value.fromBigInt(BigInt.zero()));
    this.set("newLeverageRatio", Value.fromBigInt(BigInt.zero()));
    this.set("chunkRebalanceNotional", Value.fromBigInt(BigInt.zero()));
    this.set("totalRebalanceNotional", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Disengaged entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save Disengaged entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("Disengaged", id.toString(), this);
    }
  }

  static load(id: string): Disengaged | null {
    return changetype<Disengaged | null>(store.get("Disengaged", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value!.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get currentLeverageRatio(): BigInt {
    let value = this.get("currentLeverageRatio");
    return value!.toBigInt();
  }

  set currentLeverageRatio(value: BigInt) {
    this.set("currentLeverageRatio", Value.fromBigInt(value));
  }

  get newLeverageRatio(): BigInt {
    let value = this.get("newLeverageRatio");
    return value!.toBigInt();
  }

  set newLeverageRatio(value: BigInt) {
    this.set("newLeverageRatio", Value.fromBigInt(value));
  }

  get chunkRebalanceNotional(): BigInt {
    let value = this.get("chunkRebalanceNotional");
    return value!.toBigInt();
  }

  set chunkRebalanceNotional(value: BigInt) {
    this.set("chunkRebalanceNotional", Value.fromBigInt(value));
  }

  get totalRebalanceNotional(): BigInt {
    let value = this.get("totalRebalanceNotional");
    return value!.toBigInt();
  }

  set totalRebalanceNotional(value: BigInt) {
    this.set("totalRebalanceNotional", Value.fromBigInt(value));
  }
}

export class Engaged extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("timestamp", Value.fromBigInt(BigInt.zero()));
    this.set("currentLeverageRatio", Value.fromBigInt(BigInt.zero()));
    this.set("newLeverageRatio", Value.fromBigInt(BigInt.zero()));
    this.set("chunkRebalanceNotional", Value.fromBigInt(BigInt.zero()));
    this.set("totalRebalanceNotional", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Engaged entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save Engaged entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("Engaged", id.toString(), this);
    }
  }

  static load(id: string): Engaged | null {
    return changetype<Engaged | null>(store.get("Engaged", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value!.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get currentLeverageRatio(): BigInt {
    let value = this.get("currentLeverageRatio");
    return value!.toBigInt();
  }

  set currentLeverageRatio(value: BigInt) {
    this.set("currentLeverageRatio", Value.fromBigInt(value));
  }

  get newLeverageRatio(): BigInt {
    let value = this.get("newLeverageRatio");
    return value!.toBigInt();
  }

  set newLeverageRatio(value: BigInt) {
    this.set("newLeverageRatio", Value.fromBigInt(value));
  }

  get chunkRebalanceNotional(): BigInt {
    let value = this.get("chunkRebalanceNotional");
    return value!.toBigInt();
  }

  set chunkRebalanceNotional(value: BigInt) {
    this.set("chunkRebalanceNotional", Value.fromBigInt(value));
  }

  get totalRebalanceNotional(): BigInt {
    let value = this.get("totalRebalanceNotional");
    return value!.toBigInt();
  }

  set totalRebalanceNotional(value: BigInt) {
    this.set("totalRebalanceNotional", Value.fromBigInt(value));
  }
}

export class ExchangeAdded extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("_exchangeName", Value.fromString(""));
    this.set("twapMaxTradeSize", Value.fromBigInt(BigInt.zero()));
    this.set("exchangeLastTradeTimestamp", Value.fromBigInt(BigInt.zero()));
    this.set("incentivizedTwapMaxTradeSize", Value.fromBigInt(BigInt.zero()));
    this.set("leverExchangeData", Value.fromBytes(Bytes.empty()));
    this.set("deleverExchangeData", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ExchangeAdded entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save ExchangeAdded entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("ExchangeAdded", id.toString(), this);
    }
  }

  static load(id: string): ExchangeAdded | null {
    return changetype<ExchangeAdded | null>(store.get("ExchangeAdded", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get _exchangeName(): string {
    let value = this.get("_exchangeName");
    return value!.toString();
  }

  set _exchangeName(value: string) {
    this.set("_exchangeName", Value.fromString(value));
  }

  get twapMaxTradeSize(): BigInt {
    let value = this.get("twapMaxTradeSize");
    return value!.toBigInt();
  }

  set twapMaxTradeSize(value: BigInt) {
    this.set("twapMaxTradeSize", Value.fromBigInt(value));
  }

  get exchangeLastTradeTimestamp(): BigInt {
    let value = this.get("exchangeLastTradeTimestamp");
    return value!.toBigInt();
  }

  set exchangeLastTradeTimestamp(value: BigInt) {
    this.set("exchangeLastTradeTimestamp", Value.fromBigInt(value));
  }

  get incentivizedTwapMaxTradeSize(): BigInt {
    let value = this.get("incentivizedTwapMaxTradeSize");
    return value!.toBigInt();
  }

  set incentivizedTwapMaxTradeSize(value: BigInt) {
    this.set("incentivizedTwapMaxTradeSize", Value.fromBigInt(value));
  }

  get leverExchangeData(): Bytes {
    let value = this.get("leverExchangeData");
    return value!.toBytes();
  }

  set leverExchangeData(value: Bytes) {
    this.set("leverExchangeData", Value.fromBytes(value));
  }

  get deleverExchangeData(): Bytes {
    let value = this.get("deleverExchangeData");
    return value!.toBytes();
  }

  set deleverExchangeData(value: Bytes) {
    this.set("deleverExchangeData", Value.fromBytes(value));
  }
}

export class ExchangeRemoved extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("_exchangeName", Value.fromString(""));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ExchangeRemoved entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save ExchangeRemoved entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("ExchangeRemoved", id.toString(), this);
    }
  }

  static load(id: string): ExchangeRemoved | null {
    return changetype<ExchangeRemoved | null>(store.get("ExchangeRemoved", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get _exchangeName(): string {
    let value = this.get("_exchangeName");
    return value!.toString();
  }

  set _exchangeName(value: string) {
    this.set("_exchangeName", Value.fromString(value));
  }
}

export class ExchangeUpdated extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("_exchangeName", Value.fromString(""));
    this.set("twapMaxTradeSize", Value.fromBigInt(BigInt.zero()));
    this.set("exchangeLastTradeTimestamp", Value.fromBigInt(BigInt.zero()));
    this.set("incentivizedTwapMaxTradeSize", Value.fromBigInt(BigInt.zero()));
    this.set("leverExchangeData", Value.fromBytes(Bytes.empty()));
    this.set("deleverExchangeData", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ExchangeUpdated entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save ExchangeUpdated entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("ExchangeUpdated", id.toString(), this);
    }
  }

  static load(id: string): ExchangeUpdated | null {
    return changetype<ExchangeUpdated | null>(store.get("ExchangeUpdated", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get _exchangeName(): string {
    let value = this.get("_exchangeName");
    return value!.toString();
  }

  set _exchangeName(value: string) {
    this.set("_exchangeName", Value.fromString(value));
  }

  get twapMaxTradeSize(): BigInt {
    let value = this.get("twapMaxTradeSize");
    return value!.toBigInt();
  }

  set twapMaxTradeSize(value: BigInt) {
    this.set("twapMaxTradeSize", Value.fromBigInt(value));
  }

  get exchangeLastTradeTimestamp(): BigInt {
    let value = this.get("exchangeLastTradeTimestamp");
    return value!.toBigInt();
  }

  set exchangeLastTradeTimestamp(value: BigInt) {
    this.set("exchangeLastTradeTimestamp", Value.fromBigInt(value));
  }

  get incentivizedTwapMaxTradeSize(): BigInt {
    let value = this.get("incentivizedTwapMaxTradeSize");
    return value!.toBigInt();
  }

  set incentivizedTwapMaxTradeSize(value: BigInt) {
    this.set("incentivizedTwapMaxTradeSize", Value.fromBigInt(value));
  }

  get leverExchangeData(): Bytes {
    let value = this.get("leverExchangeData");
    return value!.toBytes();
  }

  set leverExchangeData(value: Bytes) {
    this.set("leverExchangeData", Value.fromBytes(value));
  }

  get deleverExchangeData(): Bytes {
    let value = this.get("deleverExchangeData");
    return value!.toBytes();
  }

  set deleverExchangeData(value: Bytes) {
    this.set("deleverExchangeData", Value.fromBytes(value));
  }
}

export class ExecutionSettingsUpdated extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("_unutilizedLeveragePercentage", Value.fromBigInt(BigInt.zero()));
    this.set("_twapMaxTradeSize", Value.fromBigInt(BigInt.zero()));
    this.set("_twapCooldownPeriod", Value.fromBigInt(BigInt.zero()));
    this.set("_slippageTolerance", Value.fromBigInt(BigInt.zero()));
    this.set("_exchangeName", Value.fromString(""));
    this.set("_exchangeData", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save ExecutionSettingsUpdated entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save ExecutionSettingsUpdated entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("ExecutionSettingsUpdated", id.toString(), this);
    }
  }

  static load(id: string): ExecutionSettingsUpdated | null {
    return changetype<ExecutionSettingsUpdated | null>(
      store.get("ExecutionSettingsUpdated", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get _unutilizedLeveragePercentage(): BigInt {
    let value = this.get("_unutilizedLeveragePercentage");
    return value!.toBigInt();
  }

  set _unutilizedLeveragePercentage(value: BigInt) {
    this.set("_unutilizedLeveragePercentage", Value.fromBigInt(value));
  }

  get _twapMaxTradeSize(): BigInt {
    let value = this.get("_twapMaxTradeSize");
    return value!.toBigInt();
  }

  set _twapMaxTradeSize(value: BigInt) {
    this.set("_twapMaxTradeSize", Value.fromBigInt(value));
  }

  get _twapCooldownPeriod(): BigInt {
    let value = this.get("_twapCooldownPeriod");
    return value!.toBigInt();
  }

  set _twapCooldownPeriod(value: BigInt) {
    this.set("_twapCooldownPeriod", Value.fromBigInt(value));
  }

  get _slippageTolerance(): BigInt {
    let value = this.get("_slippageTolerance");
    return value!.toBigInt();
  }

  set _slippageTolerance(value: BigInt) {
    this.set("_slippageTolerance", Value.fromBigInt(value));
  }

  get _exchangeName(): string {
    let value = this.get("_exchangeName");
    return value!.toString();
  }

  set _exchangeName(value: string) {
    this.set("_exchangeName", Value.fromString(value));
  }

  get _exchangeData(): Bytes {
    let value = this.get("_exchangeData");
    return value!.toBytes();
  }

  set _exchangeData(value: Bytes) {
    this.set("_exchangeData", Value.fromBytes(value));
  }
}

export class IncentiveSettingsUpdated extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("_etherReward", Value.fromBigInt(BigInt.zero()));
    this.set("_incentivizedLeverageRatio", Value.fromBigInt(BigInt.zero()));
    this.set("_incentivizedSlippageTolerance", Value.fromBigInt(BigInt.zero()));
    this.set(
      "_incentivizedTwapCooldownPeriod",
      Value.fromBigInt(BigInt.zero())
    );
    this.set("_incentivizedTwapMaxTradeSize", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save IncentiveSettingsUpdated entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save IncentiveSettingsUpdated entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("IncentiveSettingsUpdated", id.toString(), this);
    }
  }

  static load(id: string): IncentiveSettingsUpdated | null {
    return changetype<IncentiveSettingsUpdated | null>(
      store.get("IncentiveSettingsUpdated", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get _etherReward(): BigInt {
    let value = this.get("_etherReward");
    return value!.toBigInt();
  }

  set _etherReward(value: BigInt) {
    this.set("_etherReward", Value.fromBigInt(value));
  }

  get _incentivizedLeverageRatio(): BigInt {
    let value = this.get("_incentivizedLeverageRatio");
    return value!.toBigInt();
  }

  set _incentivizedLeverageRatio(value: BigInt) {
    this.set("_incentivizedLeverageRatio", Value.fromBigInt(value));
  }

  get _incentivizedSlippageTolerance(): BigInt {
    let value = this.get("_incentivizedSlippageTolerance");
    return value!.toBigInt();
  }

  set _incentivizedSlippageTolerance(value: BigInt) {
    this.set("_incentivizedSlippageTolerance", Value.fromBigInt(value));
  }

  get _incentivizedTwapCooldownPeriod(): BigInt {
    let value = this.get("_incentivizedTwapCooldownPeriod");
    return value!.toBigInt();
  }

  set _incentivizedTwapCooldownPeriod(value: BigInt) {
    this.set("_incentivizedTwapCooldownPeriod", Value.fromBigInt(value));
  }

  get _incentivizedTwapMaxTradeSize(): BigInt {
    let value = this.get("_incentivizedTwapMaxTradeSize");
    return value!.toBigInt();
  }

  set _incentivizedTwapMaxTradeSize(value: BigInt) {
    this.set("_incentivizedTwapMaxTradeSize", Value.fromBigInt(value));
  }
}

export class MethodologySettingsUpdated extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("_targetLeverageRatio", Value.fromBigInt(BigInt.zero()));
    this.set("_minLeverageRatio", Value.fromBigInt(BigInt.zero()));
    this.set("_maxLeverageRatio", Value.fromBigInt(BigInt.zero()));
    this.set("_recenteringSpeed", Value.fromBigInt(BigInt.zero()));
    this.set("_rebalanceInterval", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save MethodologySettingsUpdated entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save MethodologySettingsUpdated entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("MethodologySettingsUpdated", id.toString(), this);
    }
  }

  static load(id: string): MethodologySettingsUpdated | null {
    return changetype<MethodologySettingsUpdated | null>(
      store.get("MethodologySettingsUpdated", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get _targetLeverageRatio(): BigInt {
    let value = this.get("_targetLeverageRatio");
    return value!.toBigInt();
  }

  set _targetLeverageRatio(value: BigInt) {
    this.set("_targetLeverageRatio", Value.fromBigInt(value));
  }

  get _minLeverageRatio(): BigInt {
    let value = this.get("_minLeverageRatio");
    return value!.toBigInt();
  }

  set _minLeverageRatio(value: BigInt) {
    this.set("_minLeverageRatio", Value.fromBigInt(value));
  }

  get _maxLeverageRatio(): BigInt {
    let value = this.get("_maxLeverageRatio");
    return value!.toBigInt();
  }

  set _maxLeverageRatio(value: BigInt) {
    this.set("_maxLeverageRatio", Value.fromBigInt(value));
  }

  get _recenteringSpeed(): BigInt {
    let value = this.get("_recenteringSpeed");
    return value!.toBigInt();
  }

  set _recenteringSpeed(value: BigInt) {
    this.set("_recenteringSpeed", Value.fromBigInt(value));
  }

  get _rebalanceInterval(): BigInt {
    let value = this.get("_rebalanceInterval");
    return value!.toBigInt();
  }

  set _rebalanceInterval(value: BigInt) {
    this.set("_rebalanceInterval", Value.fromBigInt(value));
  }
}

export class RipcordCalled extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("timestamp", Value.fromBigInt(BigInt.zero()));
    this.set("currentLeverageRatio", Value.fromBigInt(BigInt.zero()));
    this.set("newLeverageRatio", Value.fromBigInt(BigInt.zero()));
    this.set("rebalanceNotional", Value.fromBigInt(BigInt.zero()));
    this.set("etherIncentive", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save RipcordCalled entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save RipcordCalled entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("RipcordCalled", id.toString(), this);
    }
  }

  static load(id: string): RipcordCalled | null {
    return changetype<RipcordCalled | null>(store.get("RipcordCalled", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value!.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get currentLeverageRatio(): BigInt {
    let value = this.get("currentLeverageRatio");
    return value!.toBigInt();
  }

  set currentLeverageRatio(value: BigInt) {
    this.set("currentLeverageRatio", Value.fromBigInt(value));
  }

  get newLeverageRatio(): BigInt {
    let value = this.get("newLeverageRatio");
    return value!.toBigInt();
  }

  set newLeverageRatio(value: BigInt) {
    this.set("newLeverageRatio", Value.fromBigInt(value));
  }

  get rebalanceNotional(): BigInt {
    let value = this.get("rebalanceNotional");
    return value!.toBigInt();
  }

  set rebalanceNotional(value: BigInt) {
    this.set("rebalanceNotional", Value.fromBigInt(value));
  }

  get etherIncentive(): BigInt {
    let value = this.get("etherIncentive");
    return value!.toBigInt();
  }

  set etherIncentive(value: BigInt) {
    this.set("etherIncentive", Value.fromBigInt(value));
  }
}

export class StreamingFee extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("timestamp", Value.fromBigInt(BigInt.zero()));
    this.set("setToken", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save StreamingFee entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save StreamingFee entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("StreamingFee", id.toString(), this);
    }
  }

  static load(id: string): StreamingFee | null {
    return changetype<StreamingFee | null>(store.get("StreamingFee", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value!.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get setToken(): Bytes {
    let value = this.get("setToken");
    return value!.toBytes();
  }

  set setToken(value: Bytes) {
    this.set("setToken", Value.fromBytes(value));
  }

  get managerFee(): BigInt | null {
    let value = this.get("managerFee");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set managerFee(value: BigInt | null) {
    if (!value) {
      this.unset("managerFee");
    } else {
      this.set("managerFee", Value.fromBigInt(<BigInt>value));
    }
  }

  get protocolFee(): BigInt | null {
    let value = this.get("protocolFee");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set protocolFee(value: BigInt | null) {
    if (!value) {
      this.unset("protocolFee");
    } else {
      this.set("protocolFee", Value.fromBigInt(<BigInt>value));
    }
  }

  get newStreamingFee(): BigInt | null {
    let value = this.get("newStreamingFee");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set newStreamingFee(value: BigInt | null) {
    if (!value) {
      this.unset("newStreamingFee");
    } else {
      this.set("newStreamingFee", Value.fromBigInt(<BigInt>value));
    }
  }

  get newFeeRecipient(): Bytes | null {
    let value = this.get("newFeeRecipient");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set newFeeRecipient(value: Bytes | null) {
    if (!value) {
      this.unset("newFeeRecipient");
    } else {
      this.set("newFeeRecipient", Value.fromBytes(<Bytes>value));
    }
  }
}
