// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  TypedMap,
  Entity,
  Value,
  ValueKind,
  store,
  Address,
  Bytes,
  BigInt,
  BigDecimal
} from "@graphprotocol/graph-ts";

export class AnyoneCallableUpdated extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save AnyoneCallableUpdated entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save AnyoneCallableUpdated entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("AnyoneCallableUpdated", id.toString(), this);
  }

  static load(id: string): AnyoneCallableUpdated | null {
    return store.get(
      "AnyoneCallableUpdated",
      id
    ) as AnyoneCallableUpdated | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get _status(): boolean {
    let value = this.get("_status");
    return value.toBoolean();
  }

  set _status(value: boolean) {
    this.set("_status", Value.fromBoolean(value));
  }
}

export class CallerStatusUpdated extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save CallerStatusUpdated entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save CallerStatusUpdated entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("CallerStatusUpdated", id.toString(), this);
  }

  static load(id: string): CallerStatusUpdated | null {
    return store.get("CallerStatusUpdated", id) as CallerStatusUpdated | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get _caller(): Bytes {
    let value = this.get("_caller");
    return value.toBytes();
  }

  set _caller(value: Bytes) {
    this.set("_caller", Value.fromBytes(value));
  }

  get _status(): boolean {
    let value = this.get("_status");
    return value.toBoolean();
  }

  set _status(value: boolean) {
    this.set("_status", Value.fromBoolean(value));
  }
}

export class Transaction extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save Transaction entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Transaction entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Transaction", id.toString(), this);
  }

  static load(id: string): Transaction | null {
    return store.get("Transaction", id) as Transaction | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get from(): Bytes {
    let value = this.get("from");
    return value.toBytes();
  }

  set from(value: Bytes) {
    this.set("from", Value.fromBytes(value));
  }

  get to(): Bytes {
    let value = this.get("to");
    return value.toBytes();
  }

  set to(value: Bytes) {
    this.set("to", Value.fromBytes(value));
  }
}

export class Transfer extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save Transfer entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Transfer entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Transfer", id.toString(), this);
  }

  static load(id: string): Transfer | null {
    return store.get("Transfer", id) as Transfer | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get from(): Bytes | null {
    let value = this.get("from");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set from(value: Bytes | null) {
    if (value === null) {
      this.unset("from");
    } else {
      this.set("from", Value.fromBytes(value as Bytes));
    }
  }

  get to(): Bytes | null {
    let value = this.get("to");
    if (value === null || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set to(value: Bytes | null) {
    if (value === null) {
      this.unset("to");
    } else {
      this.set("to", Value.fromBytes(value as Bytes));
    }
  }

  get value(): BigInt {
    let value = this.get("value");
    return value.toBigInt();
  }

  set value(value: BigInt) {
    this.set("value", Value.fromBigInt(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }
}

export class Disengaged extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save Disengaged entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Disengaged entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Disengaged", id.toString(), this);
  }

  static load(id: string): Disengaged | null {
    return store.get("Disengaged", id) as Disengaged | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get currentLeverageRatio(): BigInt {
    let value = this.get("currentLeverageRatio");
    return value.toBigInt();
  }

  set currentLeverageRatio(value: BigInt) {
    this.set("currentLeverageRatio", Value.fromBigInt(value));
  }

  get newLeverageRatio(): BigInt {
    let value = this.get("newLeverageRatio");
    return value.toBigInt();
  }

  set newLeverageRatio(value: BigInt) {
    this.set("newLeverageRatio", Value.fromBigInt(value));
  }

  get chunkRebalanceNotional(): BigInt {
    let value = this.get("chunkRebalanceNotional");
    return value.toBigInt();
  }

  set chunkRebalanceNotional(value: BigInt) {
    this.set("chunkRebalanceNotional", Value.fromBigInt(value));
  }

  get totalRebalanceNotional(): BigInt {
    let value = this.get("totalRebalanceNotional");
    return value.toBigInt();
  }

  set totalRebalanceNotional(value: BigInt) {
    this.set("totalRebalanceNotional", Value.fromBigInt(value));
  }
}

export class Engaged extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save Engaged entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Engaged entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Engaged", id.toString(), this);
  }

  static load(id: string): Engaged | null {
    return store.get("Engaged", id) as Engaged | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get currentLeverageRatio(): BigInt {
    let value = this.get("currentLeverageRatio");
    return value.toBigInt();
  }

  set currentLeverageRatio(value: BigInt) {
    this.set("currentLeverageRatio", Value.fromBigInt(value));
  }

  get newLeverageRatio(): BigInt {
    let value = this.get("newLeverageRatio");
    return value.toBigInt();
  }

  set newLeverageRatio(value: BigInt) {
    this.set("newLeverageRatio", Value.fromBigInt(value));
  }

  get chunkRebalanceNotional(): BigInt {
    let value = this.get("chunkRebalanceNotional");
    return value.toBigInt();
  }

  set chunkRebalanceNotional(value: BigInt) {
    this.set("chunkRebalanceNotional", Value.fromBigInt(value));
  }

  get totalRebalanceNotional(): BigInt {
    let value = this.get("totalRebalanceNotional");
    return value.toBigInt();
  }

  set totalRebalanceNotional(value: BigInt) {
    this.set("totalRebalanceNotional", Value.fromBigInt(value));
  }
}

export class ExchangeAdded extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save ExchangeAdded entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save ExchangeAdded entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("ExchangeAdded", id.toString(), this);
  }

  static load(id: string): ExchangeAdded | null {
    return store.get("ExchangeAdded", id) as ExchangeAdded | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get _exchangeName(): string {
    let value = this.get("_exchangeName");
    return value.toString();
  }

  set _exchangeName(value: string) {
    this.set("_exchangeName", Value.fromString(value));
  }

  get twapMaxTradeSize(): BigInt {
    let value = this.get("twapMaxTradeSize");
    return value.toBigInt();
  }

  set twapMaxTradeSize(value: BigInt) {
    this.set("twapMaxTradeSize", Value.fromBigInt(value));
  }

  get exchangeLastTradeTimestamp(): BigInt {
    let value = this.get("exchangeLastTradeTimestamp");
    return value.toBigInt();
  }

  set exchangeLastTradeTimestamp(value: BigInt) {
    this.set("exchangeLastTradeTimestamp", Value.fromBigInt(value));
  }

  get incentivizedTwapMaxTradeSize(): BigInt {
    let value = this.get("incentivizedTwapMaxTradeSize");
    return value.toBigInt();
  }

  set incentivizedTwapMaxTradeSize(value: BigInt) {
    this.set("incentivizedTwapMaxTradeSize", Value.fromBigInt(value));
  }

  get leverExchangeData(): Bytes {
    let value = this.get("leverExchangeData");
    return value.toBytes();
  }

  set leverExchangeData(value: Bytes) {
    this.set("leverExchangeData", Value.fromBytes(value));
  }

  get deleverExchangeData(): Bytes {
    let value = this.get("deleverExchangeData");
    return value.toBytes();
  }

  set deleverExchangeData(value: Bytes) {
    this.set("deleverExchangeData", Value.fromBytes(value));
  }
}

export class ExchangeRemoved extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save ExchangeRemoved entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save ExchangeRemoved entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("ExchangeRemoved", id.toString(), this);
  }

  static load(id: string): ExchangeRemoved | null {
    return store.get("ExchangeRemoved", id) as ExchangeRemoved | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get _exchangeName(): string {
    let value = this.get("_exchangeName");
    return value.toString();
  }

  set _exchangeName(value: string) {
    this.set("_exchangeName", Value.fromString(value));
  }
}

export class ExchangeUpdated extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save ExchangeUpdated entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save ExchangeUpdated entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("ExchangeUpdated", id.toString(), this);
  }

  static load(id: string): ExchangeUpdated | null {
    return store.get("ExchangeUpdated", id) as ExchangeUpdated | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get _exchangeName(): string {
    let value = this.get("_exchangeName");
    return value.toString();
  }

  set _exchangeName(value: string) {
    this.set("_exchangeName", Value.fromString(value));
  }

  get twapMaxTradeSize(): BigInt {
    let value = this.get("twapMaxTradeSize");
    return value.toBigInt();
  }

  set twapMaxTradeSize(value: BigInt) {
    this.set("twapMaxTradeSize", Value.fromBigInt(value));
  }

  get exchangeLastTradeTimestamp(): BigInt {
    let value = this.get("exchangeLastTradeTimestamp");
    return value.toBigInt();
  }

  set exchangeLastTradeTimestamp(value: BigInt) {
    this.set("exchangeLastTradeTimestamp", Value.fromBigInt(value));
  }

  get incentivizedTwapMaxTradeSize(): BigInt {
    let value = this.get("incentivizedTwapMaxTradeSize");
    return value.toBigInt();
  }

  set incentivizedTwapMaxTradeSize(value: BigInt) {
    this.set("incentivizedTwapMaxTradeSize", Value.fromBigInt(value));
  }

  get leverExchangeData(): Bytes {
    let value = this.get("leverExchangeData");
    return value.toBytes();
  }

  set leverExchangeData(value: Bytes) {
    this.set("leverExchangeData", Value.fromBytes(value));
  }

  get deleverExchangeData(): Bytes {
    let value = this.get("deleverExchangeData");
    return value.toBytes();
  }

  set deleverExchangeData(value: Bytes) {
    this.set("deleverExchangeData", Value.fromBytes(value));
  }
}

export class ExecutionSettingsUpdated extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save ExecutionSettingsUpdated entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save ExecutionSettingsUpdated entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("ExecutionSettingsUpdated", id.toString(), this);
  }

  static load(id: string): ExecutionSettingsUpdated | null {
    return store.get(
      "ExecutionSettingsUpdated",
      id
    ) as ExecutionSettingsUpdated | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get _unutilizedLeveragePercentage(): BigInt {
    let value = this.get("_unutilizedLeveragePercentage");
    return value.toBigInt();
  }

  set _unutilizedLeveragePercentage(value: BigInt) {
    this.set("_unutilizedLeveragePercentage", Value.fromBigInt(value));
  }

  get _twapMaxTradeSize(): BigInt {
    let value = this.get("_twapMaxTradeSize");
    return value.toBigInt();
  }

  set _twapMaxTradeSize(value: BigInt) {
    this.set("_twapMaxTradeSize", Value.fromBigInt(value));
  }

  get _twapCooldownPeriod(): BigInt {
    let value = this.get("_twapCooldownPeriod");
    return value.toBigInt();
  }

  set _twapCooldownPeriod(value: BigInt) {
    this.set("_twapCooldownPeriod", Value.fromBigInt(value));
  }

  get _slippageTolerance(): BigInt {
    let value = this.get("_slippageTolerance");
    return value.toBigInt();
  }

  set _slippageTolerance(value: BigInt) {
    this.set("_slippageTolerance", Value.fromBigInt(value));
  }

  get _exchangeName(): string {
    let value = this.get("_exchangeName");
    return value.toString();
  }

  set _exchangeName(value: string) {
    this.set("_exchangeName", Value.fromString(value));
  }

  get _exchangeData(): Bytes {
    let value = this.get("_exchangeData");
    return value.toBytes();
  }

  set _exchangeData(value: Bytes) {
    this.set("_exchangeData", Value.fromBytes(value));
  }
}

export class IncentiveSettingsUpdated extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save IncentiveSettingsUpdated entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save IncentiveSettingsUpdated entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("IncentiveSettingsUpdated", id.toString(), this);
  }

  static load(id: string): IncentiveSettingsUpdated | null {
    return store.get(
      "IncentiveSettingsUpdated",
      id
    ) as IncentiveSettingsUpdated | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get _etherReward(): BigInt {
    let value = this.get("_etherReward");
    return value.toBigInt();
  }

  set _etherReward(value: BigInt) {
    this.set("_etherReward", Value.fromBigInt(value));
  }

  get _incentivizedLeverageRatio(): BigInt {
    let value = this.get("_incentivizedLeverageRatio");
    return value.toBigInt();
  }

  set _incentivizedLeverageRatio(value: BigInt) {
    this.set("_incentivizedLeverageRatio", Value.fromBigInt(value));
  }

  get _incentivizedSlippageTolerance(): BigInt {
    let value = this.get("_incentivizedSlippageTolerance");
    return value.toBigInt();
  }

  set _incentivizedSlippageTolerance(value: BigInt) {
    this.set("_incentivizedSlippageTolerance", Value.fromBigInt(value));
  }

  get _incentivizedTwapCooldownPeriod(): BigInt {
    let value = this.get("_incentivizedTwapCooldownPeriod");
    return value.toBigInt();
  }

  set _incentivizedTwapCooldownPeriod(value: BigInt) {
    this.set("_incentivizedTwapCooldownPeriod", Value.fromBigInt(value));
  }

  get _incentivizedTwapMaxTradeSize(): BigInt {
    let value = this.get("_incentivizedTwapMaxTradeSize");
    return value.toBigInt();
  }

  set _incentivizedTwapMaxTradeSize(value: BigInt) {
    this.set("_incentivizedTwapMaxTradeSize", Value.fromBigInt(value));
  }
}

export class MethodologySettingsUpdated extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id !== null,
      "Cannot save MethodologySettingsUpdated entity without an ID"
    );
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save MethodologySettingsUpdated entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("MethodologySettingsUpdated", id.toString(), this);
  }

  static load(id: string): MethodologySettingsUpdated | null {
    return store.get(
      "MethodologySettingsUpdated",
      id
    ) as MethodologySettingsUpdated | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get _targetLeverageRatio(): BigInt {
    let value = this.get("_targetLeverageRatio");
    return value.toBigInt();
  }

  set _targetLeverageRatio(value: BigInt) {
    this.set("_targetLeverageRatio", Value.fromBigInt(value));
  }

  get _minLeverageRatio(): BigInt {
    let value = this.get("_minLeverageRatio");
    return value.toBigInt();
  }

  set _minLeverageRatio(value: BigInt) {
    this.set("_minLeverageRatio", Value.fromBigInt(value));
  }

  get _maxLeverageRatio(): BigInt {
    let value = this.get("_maxLeverageRatio");
    return value.toBigInt();
  }

  set _maxLeverageRatio(value: BigInt) {
    this.set("_maxLeverageRatio", Value.fromBigInt(value));
  }

  get _recenteringSpeed(): BigInt {
    let value = this.get("_recenteringSpeed");
    return value.toBigInt();
  }

  set _recenteringSpeed(value: BigInt) {
    this.set("_recenteringSpeed", Value.fromBigInt(value));
  }

  get _rebalanceInterval(): BigInt {
    let value = this.get("_rebalanceInterval");
    return value.toBigInt();
  }

  set _rebalanceInterval(value: BigInt) {
    this.set("_rebalanceInterval", Value.fromBigInt(value));
  }
}

export class RebalanceIterated extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save RebalanceIterated entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save RebalanceIterated entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("RebalanceIterated", id.toString(), this);
  }

  static load(id: string): RebalanceIterated | null {
    return store.get("RebalanceIterated", id) as RebalanceIterated | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get currentLeverageRatio(): BigInt {
    let value = this.get("currentLeverageRatio");
    return value.toBigInt();
  }

  set currentLeverageRatio(value: BigInt) {
    this.set("currentLeverageRatio", Value.fromBigInt(value));
  }

  get newLeverageRatio(): BigInt {
    let value = this.get("newLeverageRatio");
    return value.toBigInt();
  }

  set newLeverageRatio(value: BigInt) {
    this.set("newLeverageRatio", Value.fromBigInt(value));
  }

  get chunkRebalanceNotional(): BigInt {
    let value = this.get("chunkRebalanceNotional");
    return value.toBigInt();
  }

  set chunkRebalanceNotional(value: BigInt) {
    this.set("chunkRebalanceNotional", Value.fromBigInt(value));
  }

  get totalRebalanceNotional(): BigInt {
    let value = this.get("totalRebalanceNotional");
    return value.toBigInt();
  }

  set totalRebalanceNotional(value: BigInt) {
    this.set("totalRebalanceNotional", Value.fromBigInt(value));
  }
}

export class Rebalanced extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save Rebalanced entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save Rebalanced entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("Rebalanced", id.toString(), this);
  }

  static load(id: string): Rebalanced | null {
    return store.get("Rebalanced", id) as Rebalanced | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get currentLeverageRatio(): BigInt {
    let value = this.get("currentLeverageRatio");
    return value.toBigInt();
  }

  set currentLeverageRatio(value: BigInt) {
    this.set("currentLeverageRatio", Value.fromBigInt(value));
  }

  get newLeverageRatio(): BigInt {
    let value = this.get("newLeverageRatio");
    return value.toBigInt();
  }

  set newLeverageRatio(value: BigInt) {
    this.set("newLeverageRatio", Value.fromBigInt(value));
  }

  get chunkRebalanceNotional(): BigInt {
    let value = this.get("chunkRebalanceNotional");
    return value.toBigInt();
  }

  set chunkRebalanceNotional(value: BigInt) {
    this.set("chunkRebalanceNotional", Value.fromBigInt(value));
  }

  get totalRebalanceNotional(): BigInt {
    let value = this.get("totalRebalanceNotional");
    return value.toBigInt();
  }

  set totalRebalanceNotional(value: BigInt) {
    this.set("totalRebalanceNotional", Value.fromBigInt(value));
  }

  get gasUsed(): BigInt {
    let value = this.get("gasUsed");
    return value.toBigInt();
  }

  set gasUsed(value: BigInt) {
    this.set("gasUsed", Value.fromBigInt(value));
  }

  get gasPriceInGwei(): BigInt {
    let value = this.get("gasPriceInGwei");
    return value.toBigInt();
  }

  set gasPriceInGwei(value: BigInt) {
    this.set("gasPriceInGwei", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class RipcordCalled extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id !== null, "Cannot save RipcordCalled entity without an ID");
    assert(
      id.kind == ValueKind.STRING,
      "Cannot save RipcordCalled entity with non-string ID. " +
        'Considering using .toHex() to convert the "id" to a string.'
    );
    store.set("RipcordCalled", id.toString(), this);
  }

  static load(id: string): RipcordCalled | null {
    return store.get("RipcordCalled", id) as RipcordCalled | null;
  }

  get id(): string {
    let value = this.get("id");
    return value.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get currentLeverageRatio(): BigInt {
    let value = this.get("currentLeverageRatio");
    return value.toBigInt();
  }

  set currentLeverageRatio(value: BigInt) {
    this.set("currentLeverageRatio", Value.fromBigInt(value));
  }

  get newLeverageRatio(): BigInt {
    let value = this.get("newLeverageRatio");
    return value.toBigInt();
  }

  set newLeverageRatio(value: BigInt) {
    this.set("newLeverageRatio", Value.fromBigInt(value));
  }

  get rebalanceNotional(): BigInt {
    let value = this.get("rebalanceNotional");
    return value.toBigInt();
  }

  set rebalanceNotional(value: BigInt) {
    this.set("rebalanceNotional", Value.fromBigInt(value));
  }

  get etherIncentive(): BigInt {
    let value = this.get("etherIncentive");
    return value.toBigInt();
  }

  set etherIncentive(value: BigInt) {
    this.set("etherIncentive", Value.fromBigInt(value));
  }
}
